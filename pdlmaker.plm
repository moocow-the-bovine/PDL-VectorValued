## -*- Mode: CPerl -*-
##
## File: pdlmaker.plm
## Author: Bryan Jurish <moocow@cpan.org>
## Description: hacks for CPAN-friendly PDL module distribution
##
## Usage:
##  + optionally set the variable @MY::pdpm in the top-level Makefile.PL
##    - if unset, scans MANIFEST for BASE.pd files and reads comments of the form `# pm=PMFILE'
##      on the same line (hash and pm= are optional)
##    - otherwise defaults for BASE.pd to BASE.pm
##  + optionally set the variable $MY::README (boolean); default is
##      $MY::README = grep {-e $_} (<README.txt>,<README.pod>,<README.rpod>)
##  + read this file in top-level Makefile.PL:
##      require "pdlmaker.plm";
##  + call pdlmaker_init([$pdfile, $pmbase, $module]) as for pdlpp_stdargs()
##  + call WriteMakefile() as usual
##  + omit the pdlpp_postamble() call from MY::postamble()
##    (you still need to 'use PDL::Core::Dev' though)
##
## Effects:
##  + clobbers sub ExtUtils::MakeMaker::WriteMakefile()
##    - unlinks all @MY::pdpm files before calling "real" WriteMakefile()
##  + clobbers MY::depend (appends)
##    - adds @MY::pdpm dependencies to dist,distcheck,create_distdir
##    - also adds README.txt dependencies if README.txt or README.rpod is present
##  + clobbers MY::special_targets (appends)
##    - adds (pm|pod|rpod) -> (txt|html) rules
##  #+ clobbers MY::distdir (changes)
##  #  - copies @MY::pdpm files to distribution directory in create_distdir: rule
##  + clobbers MY::postamble (appends)
##    - adds pdlpp_postamble($::package) if $::package is defined

package MY;
use ExtUtils::MakeMaker qw();
use ExtUtils::Manifest qw();
use Cwd qw(cwd abs_path);
use File::Basename qw(dirname basename);
use strict;

##----------------------------------------------------------------------
sub pdlmaker_init {
  my $package = shift;
  my @pdpm = $package ? "$package->[1].pm" : qw();

  my $cwd   = cwd();
  my $label = "pdlmaker_init [DIR=$cwd]";
  #print STDERR "$label\n";

  ##----------------------------
  ## read manifest @pdpm (for user info message)
  if (-r 'MANIFEST') {
    my $mani = ExtUtils::Manifest::maniread();
    my ($pd,$pm);
    foreach $pd (grep {/\.pd$/i} keys %$mani) {
      if ($mani->{$pd}) {
	($pm=$mani->{$pd}) =~ s/^[\#\s]*(?:pm=)?//;
	if ($pm) {
	  push(@pdpm,$pm);
	  next;
	}
      }
      ($pm=$pd)=~s/\.pd$/\.pm/i;
      push(@pdpm,$pm);
    }
    print STDERR "Info: ignore any warnings about missing $pm\n";
  }
  elsif (0 && $package) {
    print STDERR "Info: ignore any warnings about missing $package->[1].pm\n";
    ;
  }
  my %pdpm = (map {($_=>undef)} @pdpm);

  ##----------------------------
  ## $MY::README
  if (!defined($MY::README)) {
    $MY::README = grep {-e $_} map {glob("README.$_")} qw(txt pod rpod);
  }

  ##----------------------------
  ## unlink @pdpm files here
  foreach (@pdpm) {
    #print STDERR "$label: UNLINK $_\n";
    unlink($_) if (-e $_);
  }

  ##----------------------------
  ## @missed = ExtUtils::Manifest::manicheck()
  ##  + ignore @pdpm files in manicheck
  my $_manicheck0 = \&ExtUtils::Manifest::manicheck;
  my $_manicheck1 = sub {
    grep {!exists($pdpm{$_})} $_manicheck0->(@_);
  };
  *ExtUtils::Manifest::manicheck = $_manicheck1;

  ##----------------------------
  ## depend()
  ##  + add @pdpm, README.txt
  my $depend = sub {
    my $inherited = shift->SUPER::depend(@_);
    my $deps = join(' ', ($MY::README ? 'README.txt' : qw()), @pdpm);
    return $inherited if (!$deps);
    return $inherited .<<EOF;

dist: $deps

distcheck: $deps

create_distdir: $deps

EOF
  };
  *MY::depend = $depend;

  ##----------------------------
  ## special_targets()
  ##  + add .SUFFIXES, (pm|pod|rpod)->(txt|html)
  my $special_targets = sub {
    my $inherited = shift->SUPER::special_targets(@_);
    $inherited .= <<EOF;

.SUFFIXES: .pm .pod .rpod .txt .html

.pm.html:
	pod2html --outfile \$@ \$<

.pm.txt:
	pod2text \$< \$@

.pod.html:
	pod2html --outfile \$@ \$<

.pod.txt:
	pod2text \$< \$@

.rpod.html:
	pod2html --outfile \$@ \$<

.rpod.txt:
	pod2text \$< \$@

EOF

    foreach (@pdpm) {
      my ($dir,$base) = (dirname($_),basename($_));
      if ($dir ne '.') {
	$inherited .= "$_:\n\t\$(MAKE) -C $dir $base\n\n";
      }
    }

    return $inherited;
  };
  *MY::special_targets = $special_targets;

  ##----------------------------
  ## postamble()
  ##  + add pdlpp postamble if available
  my $postamble = sub {
    my $inherited = shift->SUPER::postamble();
    if (defined($package) && UNIVERSAL::can('PDL::Core::Dev','pdlpp_postamble')) {
      $inherited .= PDL::Core::Dev::pdlpp_postamble($package);
    }
    $inherited;
  };
  *MY::postamble = $postamble;

  ##---------------------------
  ## returning list context? --> call pdlpp_stdargs()
  return ::pdlpp_stdargs($package,@_) if ($package && wantarray && UNIVERSAL::can('main','pdlpp_stdargs'));
}

##----------------------------------------------------------------------
package main;
*pdlmaker_init = \&MY::pdlmaker_init;


1; ##-- be happy
